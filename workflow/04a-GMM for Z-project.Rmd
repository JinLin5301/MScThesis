---
title: "04a-GMM for Z-project"
date: "Compiled at `r format(Sys.time(), '%Y-%m-%d %H:%M:%S', tz = 'UTC')` UTC"
output: github_document
params:
  name: "04a-GMM for Z-project" # change if you rename file
---

```{r here, message=FALSE}
here::i_am(paste0(params$name, ".Rmd"), uuid = "9d6a84ea-ebe8-4073-bfe1-9e2529a9d667")
```

The purpose of this document is ...

```{r packages}
library("conflicted")
library(purrr)
library(dplyr)
library(flowCore)
library(mclust)
library(flowClust)
library(MASS)
```

```{r directories}
# create or *empty* the target directory, used to write this file's data: 
projthis::proj_create_dir_target(params$name, clean = TRUE)

# function to get path to target directory: path_target("sample.csv")
path_target <- projthis::proj_path_target(params$name)

# function to get path to previous data: path_source("00-import", "sample.csv")
path_source <- projthis::proj_path_source(params$name)
```

## Import data
```{r import}
DAPI <- readRDS("~/Desktop/MSc_new_data/new_DAPI.rds")
FDA_PI <- readRDS("~/Desktop/MSc_new_data/new_FDA_PI.rds")
gating_DAPI <- readRDS("~/Desktop/MSc_new_data/gating_DAPI.rds")
gating_FDA_PI <- readRDS("~/Desktop/MSc_new_data/gating_FDA_PI.rds")
```

Generate function body.

```{r function}
flowGMM <- function(data,n_cluster){
  model1 <- Mclust(data,G=n_cluster,modelNames = "VVV")
  summary(model1)

  clusters1 <- predict(model1)
  result1 <- cbind(data,Cluster=clusters1$classification)
  result1 <- as.data.frame(result1)
  result1$Cluster <- as.factor(result1$Cluster)
  
  result <- list(model=model1,parameter=model1$parameters,class_result=result1)
  return(result)
}
```

# GMM 

### Gating

In the first part, we don't specify the number of clusters, the best results will be determined by cross validation.

```{r application}
DAPI_GMM <- list()
DAPI_GMM_3D <- list()

for (i in 1:5){
  data <- DAPI[[i]]@exprs[,c(11,27)]
  data_name <- names(DAPI)[i]
  DAPI_GMM[[data_name]]<-flowGMM(data,NULL)
  
  plot(DAPI_GMM[[i]]$model,what="classification",main=data_name,xlab="PMT.1",ylab="PMT.9")
  plot(DAPI_GMM[[i]]$model,what="BIC")
}
```

```{r 3d}
for (i in 1){
  data <- DAPI[[i]]@exprs[,c(11,13,27)]
  data_name <- names(DAPI)[i]
  DAPI_GMM_3D[[data_name]]<-flowGMM(data,NULL)
  
  plot(DAPI_GMM_3D[[i]]$model,what="classification",main=data_name)
  plot(DAPI_GMM_3D[[i]]$model,what="BIC")
}

```

### Gating plots

Next, we'd like to fix the cluster number to be the same as it generates by flowEMMi.

```{r application+flowEMMi}
DAPI_GMM_flowemmi <- list()

for (i in 1:5){
  data <- DAPI[[i]]@exprs[,c(11,27)]
  data_name <- names(DAPI)[i]
  n_cluster <- length(gating_DAPI[[i]]@sigma)
  DAPI_GMM_flowemmi[[data_name]]<-flowGMM(data,n_cluster)
  
  plot(DAPI_GMM_flowemmi[[i]]$model,what="classification",main=data_name,xlab="PMT.1",ylab="PMT.9")
}

```

## GMM-ROC Function

### for points

```{r roc-function}
GMMroc <- function(data,gating_data,CI){
  mu <- gating_data$parameter$mean
  dim <- dim(gating_data$parameter$variance$sigma)[3]
  
  sigma <- list()
  for (i in 1:dim){
    sigma[[i]] <- gating_data$parameter$variance$sigma[,,i]
  }
  
  names <- colnames(data)
  
  ncells <- nrow(data)
  n_clusters <- length(sigma)
  
  #generate mahalanobis matrix
  maha_data <- matrix(NA,nrow=ncells,ncol=n_clusters)
  
  for (i in 1:ncells){
    for(j in 1:n_clusters){
      maha_data[i,j] <- mahalanobis(data[i,],mu[,j],sigma[[j]])
    }
  }
  
  maha <- maha_data[,2:n_clusters] %>% as.data.frame()
  
  data1 <- maha
  
  roc.points <- data.frame(cell=NA,volume=NA)
  
  for (alpha in CI){
    threshold <- -2*log(1-alpha)
  
    for (cell in 1:ncells){
      rv <- data1[cell,1:ncol(data1)-1]
      if(all(rv>threshold)) {data1$Cluster[cell] <- NA}
      else {data1$Cluster[cell] <- which.min(rv)}
    }
  
    result <- table(data1$Cluster) %>% as.data.frame()
    sum1 <- sum(result$Freq)
  
    eigen <- matrix(NA,nrow=length(sigma),ncol=2)
    for (i in 1:length(sigma)){
      eigen[i,] <- eigen(sigma[[i]])$values
    }
    eigen <- eigen[-1,]
    
    if(length(sigma)>2){
    area <- matrix(NA,nrow=nrow(eigen),ncol=1)
    for (i in 1:nrow(eigen)){
      area[i,1] <- pi*sqrt(eigen[i,1]*eigen[i,2])*(-2*log(1-alpha))}
    }
    else {area <- pi*sqrt(eigen[1]*eigen[2])*(-2*log(1-alpha))}
    
    area <- as.data.frame(area)
    sum2 <- sum(area)
    sum.roc <- cbind(cell=sum1,volume=sum2)
    
    roc.points <- rbind(roc.points,sum.roc)
  }
  result <- list(roc.table=roc.points)
  return(result)
}
```

### for plots

```{r roc-plot}
# plot
plot.roc <- function(roc_result){
  
  plot.points <- data.frame()
  plot.scale <- data.frame()
  plot.scale.points <- data.frame()

  for (i in 1:5){
    data <- roc_result[[i]]
    data[1,] <- c(0,0)
  
  # No Scaling
  data$location <- substr(names(DAPI)[i],1,nchar(names(DAPI)[i])-9) %>% as.factor()
  plot.points <- rbind(plot.points,data)
  
  # Scaled by regional maximum
  max <- data[100,]
  for (j in 1:100){
    data[j,1] <- data[j,1]/max[1,1]
    data[j,2] <- data[j,2]/max[1,2]
  }
  plot.scale <- rbind(plot.scale,data1)
  
  
  # Scaled by the max number among all regions
  plot.scale.points <- plot.points
  max1 <- max(plot.scale.points[,1])
  max2 <- max(plot.scale.points[,2])
  
  for (j in 1:nrow(plot.points)){
    plot.scale.points[j,1]<- plot.scale.points[j,1]/max1
    plot.scale.points[j,2]<- plot.scale.points[j,2]/max2
    }
  }
  
  points <- list(raw.point=plot.points,regional.scaled=plot.scale,all.scaled=plot.scale.points)
  return(points)
  
}
```

### Compute ROC points

Using different gating results

```{r roc-calc points,eval=FALSE}
GMM.roc <- list()

for (i in 1:5){
  data <- DAPI[[i]]@exprs[,c(11,27)]
  data_name <- names(DAPI)[i]
  gating_data <- DAPI_GMM_flowemmi[[i]]
  alpha <- seq(0.01,0.99,0.01)
  GMM.roc[[data_name]] <- GMMroc(data,gating_data,alpha)
}
```

# flowClust

### gating

```{r flowClust-gating}
DAPI_fC_flex <- list()
DAPI_fC_fixed <- list()

# gating
for (i in 1:5){
  res <- flowClust(DAPI[[i]], varNames = c("PMT.1","PMT.9"), K=1:9)
  data_name <- names(DAPI)[i]
  bic <- criterion(res, "BIC")
  max <- which.max(bic)
  plot(res[[max]], data = DAPI[[i]], main=paste0("Flex. result for ",data_name))
  DAPI_fC_flex[[data_name]] <- res[[max]]
  
  k <- length(gating_DAPI[[i]]@sigma)
  DAPI_fC_fixed[[data_name]] <- res[[k]]
  plot(res[[k]], data = DAPI[[i]], main=paste0("Fixed result for ",data_name))
}

```

### flowClust-ROC

```{r flowClust-roc}
flowClust_roc <- function(data,gating_data,alpha){
  # Box-Cox trans
  lambda <- gating_data@lambda
  data <- flowClust::box(data,lambda)
  
  # maha-matrix
  mu <- t(gating_data@mu)
  dim <- dim(gating_data@sigma)[1]
  
  #inverse Box-Cox transformation
  invBoxCox <- function(x, lambda){
    if (lambda == 0) exp(x) 
    else (lambda*x + 1)^(1/lambda)
  }
    
  sigma <- list()
  inv.sigma <- list()
  for (i in 1:dim){
    var1 <- gating_data@sigma[i,,]
    sigma[[i]] <- var1
    #inv.sigma[[i]] <- invBoxCox(data,lambda)
  }
  
  names <- colnames(data)
  
  ncells <- nrow(data)
  n_clusters <- length(sigma)
  
  #generate mahalanobis matrix
  maha_data <- matrix(NA,nrow=ncells,ncol=n_clusters)
  
  for (i in 1:ncells){
    for(j in 1:n_clusters){
      maha_data[i,j] <- mahalanobis(data[i,],mu[,j],sigma[[j]])
    }
  }
  
  data1 <- maha_data[,2:n_clusters] %>% as.data.frame()
  
  roc.points <- data.frame(cell=NA,volume=NA)
  
  for (alpha in alpha){
    threshold <- 2*qf(alpha,2,4)
    
    for (cell in 1:ncells){
      rv <- data1[cell,1:ncol(data1)-1]
      if(all(rv>threshold)) {data1$Cluster[cell] <- NA}
      else {data1$Cluster[cell] <- which.min(rv)}
    }
  
    result <- table(data1$Cluster) %>% as.data.frame()
    sum1 <- sum(result$Freq)
    
    
    # calculate volume
    eigen <- matrix(NA,nrow=length(sigma),ncol=2)
    for (i in 1:length(sigma)){
      eigen[i,] <- eigen(sigma[[i]])$values
    }
    eigen <- eigen[-1,]
  
    area <- matrix(NA,nrow=nrow(eigen),ncol=1)
    for (i in 1:nrow(eigen)){
      area[i,1] <- pi*sqrt(eigen[i,1]*eigen[i,2])*(2*qf(alpha,2,4))
    }
    area <- as.data.frame(area)
    sum2 <- sum(area)
    sum.roc <- cbind(cell=sum1,volume=sum2)
    
    roc.points <- rbind(roc.points,sum.roc)
  }
    result <- list(maha.matrix=data1,roc.table=roc.points)
  return(result)
}
```

```{r flowClust1,eval=FALSE}
DAPI_bc <- list()
test0 <- list()

for (i in 1:5){
  name <- names(DAPI)[i]
  data0 <- DAPI[[name]]@exprs[,c(11,27)]
  gating_data <- DAPI_fC_flex[[name]]
  alpha <- seq(0.01,0.99,by=0.01)
  DAPI_bc[[name]] <- flowClust_roc(data0,gating_data,alpha)
  
  #trans=0: no box-cox
  test <- flowClust(DAPI[[i]], varNames = c("PMT.1","PMT.9"), K=9,trans = 0)
  test0[[i]] <- flowClust_roc(data0,test,alpha)
}
```


## Files written

These files have been written to the target directory, ```r paste0("data/", params$name)```:

```{r list-files-target}
projthis::proj_dir_info(path_target())
```
